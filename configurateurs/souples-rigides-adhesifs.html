<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width,initial-scale=1.0" />
<title>Configurateur ‚Äî Supports Souples, Rigides & Adh√©sifs | Cofel</title>

<!-- Styles communs Cofel -->
<link rel="stylesheet" href="../styles/cofel.css">
<link rel="stylesheet" href="../styles/cofel-components.css">
<link rel="stylesheet" href="../styles/cofel-glass.css">
<link rel="stylesheet" href="../styles/cofel-config-steps.css">
</head>

<body>

<header class="cofel-header">
  <div class="row">
    <a href="../index.html" class="cofel-back">‚¨Ö Retour</a>
    <div class="cofel-brand">
      <img src="../assets/logo cofel.jpg" alt="Cofel">
      <h1 class="cofel-title">Supports Souples, Rigides & Adh√©sifs</h1>
    </div>
  </div>
</header>

<div class="wrapper">

  <!-- BARRE D'√âTAPES -->
  <div class="steps-nav" id="stepsNav">
    <div class="step-item active" data-step="1">1. Support</div>
    <div class="step-item locked" data-step="2">2. Impression</div>
    <div class="step-item locked" data-step="3">3. Mati√®re</div>
    <div class="step-item locked" data-step="4">4. Variantes</div>
    <div class="step-item locked" data-step="5">5. D√©coupe</div>
    <div class="step-item locked" data-step="6">6. Lamination</div>
    <div class="step-item locked" data-step="7">7. Blanc</div>
    <div class="step-item locked" data-step="8" id="stepOeillets">8. ≈íillets</div>
    <div class="step-item locked" data-step="9">9. Format</div>
    <div class="step-item locked" data-step="10">10. R√©capitulatif</div>
  </div>

  <!-- √âTAPE 1 -->
  <section class="step-section active" id="step1">
    <fieldset>
      <legend>Choix du support</legend>
      <div class="radio-row">
        <label><input type="radio" name="support" value="souple"> Support souple</label>
        <label><input type="radio" name="support" value="rigide"> Support rigide</label>
      </div>
    </fieldset>
    <div class="nav-buttons"><button class="btn-nav" id="next1" type="button">√âtape suivante ‚ûú</button></div>
  </section>

  <!-- √âTAPE 2 -->
  <section class="step-section" id="step2">
    <fieldset>
      <legend>Impression</legend>
      <div class="radio-row">
        <label><input type="radio" name="impression" value="avec"> Avec impression</label>
        <label><input type="radio" name="impression" value="sans"> Sans impression</label>
      </div>
    </fieldset>
    <div class="nav-buttons">
      <button class="btn-nav" id="prev2" type="button">‚¨Ö Pr√©c√©dent</button>
      <button class="btn-nav" id="next2" type="button">√âtape suivante ‚ûú</button>
    </div>
  </section>

  <!-- √âTAPE 3 -->
  <section class="step-section" id="step3">
    <fieldset>
      <legend>Mati√®re</legend>
      <div id="listeMatieres" class="radio-row"></div>
    </fieldset>
    <div class="nav-buttons">
      <button class="btn-nav" id="prev3" type="button">‚¨Ö Pr√©c√©dent</button>
      <button class="btn-nav" id="next3" type="button">√âtape suivante ‚ûú</button>
    </div>
  </section>

  <!-- √âTAPE 4 -->
  <section class="step-section" id="step4">
    <fieldset>
      <legend>Variantes de la mati√®re</legend>
      <div id="listeVariantes" class="radio-row"></div>
    </fieldset>
    <div class="nav-buttons">
      <button class="btn-nav" id="prev4" type="button">‚¨Ö Pr√©c√©dent</button>
      <button class="btn-nav" id="next4" type="button">√âtape suivante ‚ûú</button>
    </div>
  </section>

  <!-- √âTAPE 5 -->
  <section class="step-section" id="step5">
    <fieldset>
      <legend>Type de d√©coupe</legend>
      <div id="decoupeContainer" class="radio-row"></div>
    </fieldset>
    <div class="nav-buttons">
      <button class="btn-nav" id="prev5" type="button">‚¨Ö Pr√©c√©dent</button>
      <button class="btn-nav" id="next5" type="button">√âtape suivante ‚ûú</button>
    </div>
  </section>

  <!-- √âTAPE 6 -->
  <section class="step-section" id="step6">
    <fieldset>
      <legend>Lamination</legend>
      <div id="laminationContainer" class="radio-row"></div>
      <p id="laminationInfo" class="hint"></p>
    </fieldset>
    <div class="nav-buttons">
      <button class="btn-nav" id="prev6" type="button">‚¨Ö Pr√©c√©dent</button>
      <button class="btn-nav" id="next6" type="button">√âtape suivante ‚ûú</button>
    </div>
  </section>

  <!-- √âTAPE 7 -->
  <section class="step-section" id="step7">
    <fieldset>
      <legend>Blanc de soutien</legend>
      <div id="blancContainer" class="radio-row"></div>
      <p id="blancInfo" class="hint"></p>
    </fieldset>
    <div class="nav-buttons">
      <button class="btn-nav" id="prev7" type="button">‚¨Ö Pr√©c√©dent</button>
      <button class="btn-nav" id="next7" type="button">√âtape suivante ‚ûú</button>
    </div>
  </section>

  <!-- √âTAPE 8 -->
  <section class="step-section" id="step8">
    <fieldset>
      <legend>≈íillets (Akilux uniquement)</legend>
      <div id="oeilletsContainer"></div>
      <p id="oeilletsInfo" class="hint"></p>
    </fieldset>
    <div class="nav-buttons">
      <button class="btn-nav" id="prev8" type="button">‚¨Ö Pr√©c√©dent</button>
      <button class="btn-nav" id="next8" type="button">√âtape suivante ‚ûú</button>
    </div>
  </section>

  <!-- √âTAPE 9 -->
  <section class="step-section" id="step9">
    <fieldset>
      <legend>Format & Quantit√©</legend>

      <label>Largeur (mm)</label>
      <input type="number" id="largeur" min="1" placeholder="Ex : 1200">

      <label>Hauteur (mm)</label>
      <input type="number" id="hauteur" min="1" placeholder="Ex : 800">

      <label>Quantit√©</label>
      <input type="number" id="quantite" min="1" value="1">
    </fieldset>

    <div class="nav-buttons">
      <button class="btn-nav" id="prev9" type="button">‚¨Ö Pr√©c√©dent</button>
      <button class="btn-nav" id="next9" type="button">√âtape suivante ‚ûú</button>
    </div>
  </section>

  <!-- √âTAPE 10 -->
  <section class="step-section" id="step10">
    <fieldset>
      <legend>R√©capitulatif</legend>
      <div id="recap"></div>
    </fieldset>

    <div class="nav-buttons">
      <button class="btn-nav" id="prev10" type="button">‚¨Ö Pr√©c√©dent</button>
      <button class="btn-nav" id="addToDevisBtn" type="button">‚ûï Ajouter au devis</button>
      <button class="btn-nav" id="resetBtn" type="button">‚Ü∫ R√©initialiser</button>
    </div>
  </section>

</div>

<footer class="cofel-footer">
  ¬© Cofel ‚Äî Supports Souples, Rigides & Adh√©sifs
</footer>

<!-- Ruleset -->
<script src="../js/souples-rigides-adhesifs-rules.js"></script>

<!-- M√©thode de calcul des prix -->
<script src="../js/methode-prix-matieres-souples-rigides-impression.js"></script>

<!-- Script principal -->
<script src="../js/souples-rigides-adhesifs.js"></script>

<!-- ===== Bridge: devisCourant_v1 + remise UNIQUEMENT sur mati√®re (mati√®re co√ªt √ó3,5) ===== -->
<script>
(function(){
  function q(sel){ return document.querySelector(sel); }
  function qa(sel){ return Array.from(document.querySelectorAll(sel)); }

  const STORAGE_KEY = "devisCourant_v1";
  const TVA_RATE = 0.20;

  // ‚úÖ R√®gle m√©tier demand√©e
  const COEF_MATIERE_PUBLIC = 3.5;

  function genId(){
    try{ if(window.crypto && typeof crypto.randomUUID === "function") return crypto.randomUUID(); }catch(e){}
    return "L_" + Date.now() + "_" + Math.random().toString(16).slice(2);
  }
  function round2(n){
    n = Number(n);
    return Number.isFinite(n) ? Math.round(n * 100) / 100 : 0;
  }
  function toNum(str){
    const n = parseFloat(String(str).replace(/\s+/g,'').replace(',', '.'));
    return Number.isFinite(n) ? n : null;
  }

  function getDiscountRate(){
    try{
      const p = JSON.parse(localStorage.getItem("cofel_client_profile") || "{}");
      if(typeof p.discountRate === "number" && !isNaN(p.discountRate)){
        return Math.max(0, Math.min(0.90, p.discountRate)); // 0.10 = 10%
      }
    }catch(e){}
    return 0;
  }

  function getCheckedText(containerSel){
    const root = q(containerSel);
    if(!root) return "";
    const checked = root.querySelector('input:checked');
    if(!checked) return "";
    const lab = checked.closest('label');
    return (lab ? lab.textContent : checked.value || "").trim();
  }
  function getCheckedTexts(containerSel){
    const root = q(containerSel);
    if(!root) return [];
    const checked = qa(containerSel + ' input:checked');
    return checked.map(el=>{
      const lab = el.closest('label');
      return (lab ? lab.textContent : el.value || "").trim();
    }).filter(Boolean);
  }

  // --- lecture stockage devis ---
  function readStore(){
    try{ return JSON.parse(localStorage.getItem(STORAGE_KEY) || "{}") || {}; }
    catch(e){ return {}; }
  }
  function writeStore(st){
    localStorage.setItem(STORAGE_KEY, JSON.stringify(st));
  }

  // --- extraction recap ---
  function parseRecapLines(){
    const recap = q('#recap');
    if(!recap) return [];

    const rawLines = (recap.innerText || recap.textContent || "")
      .split("\n").map(s=>s.trim()).filter(Boolean);

    const moneyRe = /(\d[\d\s]*([.,]\d+)?)\s*(?:‚Ç¨|eur\b)/gi;

    const out = [];
    for(const line of rawLines){
      const nums = [];
      let m;
      while((m = moneyRe.exec(line)) !== null){
        const n = toNum(m[1]);
        if(n != null) nums.push(n);
      }
      moneyRe.lastIndex = 0;

      if(!nums.length) continue;

      const low = line.toLowerCase();
      const isHT = low.includes("ht") && !low.includes("ttc");
      const isTTC = low.includes("ttc");
      const isTotal = /total/i.test(low);
      const isClient = /client/i.test(low);
      const isPublic = /public/i.test(low);

      out.push({
        line,
        low,
        nums,
        amount: Math.max(...nums),
        isHT,
        isTTC,
        isTotal,
        isClient,
        isPublic
      });
    }
    return out;
  }

  // ‚úÖ NOUVELLE logique : remise uniquement sur mati√®re (mati√®re co√ªt √ó3,5)
  function computeNetTotalHT_MatiereOnly(){
    const dr = getDiscountRate();
    const lines = parseRecapLines();

    // on ne travaille qu‚Äôen HT
    const htLines = lines.filter(x => x.isHT && !x.isTTC);
    if(!htLines.length) return { ok:false, reason:"no_ht_lines" };

    // infos s√©lectionn√©es (pour aider √† rep√©rer la ligne mati√®re)
    const matiereSel = getCheckedText('#listeMatieres').toLowerCase();
    const varianteSel = getCheckedText('#listeVariantes').toLowerCase();

    // mots-cl√©s prestations (d√©j√† public)
    const KEY_PREST = [
      "impression","lamination","lamin","d√©coupe","decoupe","blanc","oeillet","≈ìillet","oeillets","≈ìillets",
      "pose","frais","forfait"
    ];

    function scoreMaterial(lineLow){
      let s = 0;
      if(lineLow.includes("matiere") || lineLow.includes("mati√®re")) s += 3;
      if(lineLow.includes("support")) s += 1;

      // match s√©lection
      if(matiereSel && matiereSel.length >= 3 && lineLow.includes(matiereSel)) s += 5;
      if(varianteSel && varianteSel.length >= 3 && lineLow.includes(varianteSel)) s += 4;

      // si la ligne ressemble √† un co√ªt
      if(lineLow.includes("co√ªt") || lineLow.includes("cout") || lineLow.includes("achat") || lineLow.includes("interne")) s += 3;

      // si la ligne ressemble √† une prestation, on p√©nalise
      for(const k of KEY_PREST){
        if(lineLow.includes(k)) s -= 4;
      }

      // si c‚Äôest un total, pas une mati√®re
      if(/total/.test(lineLow)) s -= 10;
      if(/client|public/.test(lineLow)) s -= 2;

      return s;
    }

    // 1) identifier la meilleure ligne "mati√®re"
    let bestMat = null;
    let bestScore = -999;
    for(const x of htLines){
      const sc = scoreMaterial(x.low);
      if(sc > bestScore){
        bestScore = sc;
        bestMat = x;
      }
    }

    if(!bestMat || bestScore < 3){
      return { ok:false, reason:"material_not_found", bestScore, bestLine: bestMat?.line || null };
    }

    const matiereCostHT = round2(bestMat.amount);

    // 2) prestations : toutes les lignes HT (hors totaux) qui ne sont pas la mati√®re
    const componentLines = htLines.filter(x => !x.isTotal);
    let prestationsPublicHT = 0;

    for(const x of componentLines){
      if(x === bestMat) continue;
      if(x.isClient || x.isPublic) continue;
      if(/total/.test(x.low)) continue;

      prestationsPublicHT += round2(x.amount);
    }
    prestationsPublicHT = round2(prestationsPublicHT);

    // 3) appliquer la r√®gle
    const matierePublicHT = round2(matiereCostHT * COEF_MATIERE_PUBLIC);
    const matiereClientHT = round2(matierePublicHT * (1 - dr));
    const totalClientHT = round2(matiereClientHT + prestationsPublicHT);

    return {
      ok:true,
      totalClientHT,
      details:{
        discountRate: dr,
        matiereCostHT,
        matierePublicHT,
        matiereClientHT,
        prestationsPublicHT,
        materialLine: bestMat.line,
        materialScore: bestScore
      }
    };
  }

  function extractTotalHTFallback_Global(){
    const recap = q('#recap');
    if(!recap) return { usedHT: 0, source:"none" };

    const raw = (recap.innerText || recap.textContent || "").split("\n").map(s=>s.trim()).filter(Boolean);
    const moneyRe = /(\d[\d\s]*([.,]\d+)?)\s*(?:‚Ç¨|eur\b)/gi;

    const hits = [];
    for(const line of raw){
      const low = line.toLowerCase();
      if(low.includes("ttc")) continue;

      let m;
      while((m = moneyRe.exec(line)) !== null){
        const n = toNum(m[1]);
        if(n != null) hits.push({ line, low, n });
      }
      moneyRe.lastIndex = 0;
    }
    if(!hits.length) return { usedHT: 0, source:"none" };

    const client = hits.filter(x => x.low.includes("client"));
    if(client.length){
      const v = round2(Math.max(...client.map(x=>x.n)));
      return { usedHT: v, source:"client" };
    }

    const pub = hits.filter(x => x.low.includes("public"));
    const dr = getDiscountRate();
    if(pub.length && dr > 0){
      const v = round2(Math.max(...pub.map(x=>x.n)) * (1 - dr));
      return { usedHT: v, source:"public*remise_global" };
    }

    return { usedHT: round2(Math.max(...hits.map(x=>x.n))), source:"fallback_max" };
  }

  function buildLineForIndex(){
    const support = (q('input[name="support"]:checked')?.value || "").trim();
    const impression = (q('input[name="impression"]:checked')?.value || "").trim();

    const matiere = getCheckedText('#listeMatieres');
    const variante = getCheckedText('#listeVariantes');
    const decoupe = getCheckedText('#decoupeContainer');
    const lamination = getCheckedText('#laminationContainer');
    const blanc = getCheckedText('#blancContainer');
    const oeillets = getCheckedTexts('#oeilletsContainer');

    const w = parseInt(q('#largeur')?.value || "0", 10);
    const h = parseInt(q('#hauteur')?.value || "0", 10);
    const qty = Math.max(1, parseInt(q('#quantite')?.value || "1", 10) || 1);

    const parts = [];
    if(support) parts.push(support === "souple" ? "Support souple" : "Support rigide");
    if(impression) parts.push(impression === "avec" ? "Avec impression" : "Sans impression");
    if(matiere) parts.push(matiere);
    if(variante) parts.push(variante);
    if(decoupe) parts.push("D√©coupe : " + decoupe);
    if(lamination) parts.push("Lamination : " + lamination);
    if(blanc) parts.push("Blanc : " + blanc);
    if(oeillets.length) parts.push("≈íillets : " + oeillets.join(", "));
    if(w > 0 && h > 0) parts.push(`Format : ${w}√ó${h} mm`);

    const designation = parts.join(" ‚Ä¢ ") || "Supports Souples, Rigides & Adh√©sifs";
    const id = genId();

    let totalHT = 0;
    let source = "none";
    let debug = {};

    const res = computeNetTotalHT_MatiereOnly();
    if(res.ok){
      totalHT = res.totalClientHT;
      source = "matiere_only_(cout*3.5 + presta_public + remise_matiere)";
      debug = res.details;
    }else{
      const fb = extractTotalHTFallback_Global();
      totalHT = fb.usedHT;
      source = "fallback:" + fb.source;
      debug = { fallbackReason: res.reason, ...res };
    }

    const puHT = round2(totalHT / qty);

    return {
      id,
      type: "configurateur",
      designation,
      quantite: qty,
      pu_net_ht: puHT,
      total_ligne_ht: round2(puHT * qty),
      meta: {
        configurateur: "Supports Souples, Rigides & Adh√©sifs",
        largeur_mm: Number.isFinite(w) ? w : null,
        hauteur_mm: Number.isFinite(h) ? h : null,
        prix_source: source,
        discountRate: getDiscountRate(),
        coef_matiere_public: COEF_MATIERE_PUBLIC,
        debug
      }
    };
  }

  function addLineToIndexStore(line){
    const st = readStore();
    if(!Array.isArray(st.lignes)) st.lignes = [];
    st.lignes.push(line);
    writeStore(st);
  }

  document.addEventListener('DOMContentLoaded', function(){
    const addBtn = q('#addToDevisBtn');
    const resetBtn = q('#resetBtn');

    if(addBtn){
      addBtn.addEventListener('click', function(){
        try{
          const line = buildLineForIndex();
          addLineToIndexStore(line);

          const msg =
            "Ligne ajout√©e au devis ‚úÖ\n\n" +
            "Source prix : " + (line.meta?.prix_source || "?") + "\n" +
            "PU HT (net) : " + line.pu_net_ht.toFixed(2).replace('.', ',') + " ‚Ç¨\n" +
            "Total HT : " + line.total_ligne_ht.toFixed(2).replace('.', ',') + " ‚Ç¨\n\n" +
            "Revenir au devis maintenant ?";

          if(confirm(msg)) location.href = "/";
        }catch(err){
          console.error(err);
          alert("Erreur Ajouter au devis : " + (err?.message || err));
        }
      });
    }

    if(resetBtn){
      resetBtn.addEventListener('click', function(){
        if(confirm("R√©initialiser ce configurateur ?")) location.reload();
      });
    }
  });
})();
</script>

<!-- ‚úÖ UI R√âCAP : masquages demand√©s (anti-boucle) -->
<script>
(function(){
  const norm = (s) => (s || "")
    .toLowerCase()
    .normalize("NFD")
    .replace(/[\u0300-\u036f]/g, ""); // enl√®ve accents

  let cleaning = false;
  let pending = false;
  let obs = null;

  function cleanupRecap(){
    const recap = document.getElementById("recap");
    if(!recap) return;
    if(cleaning) return;

    cleaning = true;

    // üîí stop observer pendant qu'on modifie le DOM
    try { if (obs) obs.disconnect(); } catch(e){}

    try{
      // 1) Masquer "≈íillets : 0"
      Array.from(recap.querySelectorAll("p")).forEach(p => {
        const t = norm(p.textContent);
        if(t.includes("oeillet")){
          const m = p.textContent.match(/:\s*([0-9]+)/);
          const n = m ? parseInt(m[1], 10) : 0;
          if(!n) p.remove();
        }
      });

      // 2) Supprimer "Prix public" + "Remise client"
      Array.from(recap.querySelectorAll("p")).forEach(p => {
        const t = norm(p.textContent);
        if(t.includes("prix public") || t.includes("remise client")){
          p.remove();
        }
      });

      // 3) Renommer "Prix client ..." => "Prix client hors-taxe"
      Array.from(recap.querySelectorAll("p b")).forEach(b => {
        const t = norm(b.textContent);
        if(t.includes("prix client") && !t.includes("hors-taxe")){
          b.textContent = "Prix client hors-taxe :";
        }
      });

      // 4) Enlever le <hr> (optionnel, mais tu voulais un r√©cap plus clean)
      Array.from(recap.querySelectorAll("hr")).forEach(hr => hr.remove());

    } finally {
      // üîì relance observer (seulement quand #recap est r√©-√©crit)
      try{
        if (obs) {
          obs.observe(recap, { childList: true }); // childList suffit (renderRecap remplace le contenu)
        }
      }catch(e){}
      cleaning = false;
    }
  }

  document.addEventListener("DOMContentLoaded", () => {
    const recap = document.getElementById("recap");
    if(!recap) return;

    // observer : on d√©clenche 1 nettoyage par frame max
    obs = new MutationObserver(() => {
      if (cleaning || pending) return;
      pending = true;
      requestAnimationFrame(() => {
        pending = false;
        cleanupRecap();
      });
    });

    // 1er nettoyage + armement
    cleanupRecap();
    obs.observe(recap, { childList: true });
  });
})();
</script>


</body>
</html>
